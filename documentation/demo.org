#+title: dtache.el - Dtach Emacs
#+author: Niklas Eklund
#+language: en

* COMMENT Preparations

A simple script that runs for 20 seconds.

#+begin_src sh :tangle /tmp/dtache/loop.sh :tangle-mode (identity #o755)
  for i in {1..20} ; do sleep 1; echo "$i" ; done
#+end_src

Tangle the code block above into a shell script.

#+begin_src elisp :results none
  (call-interactively #'org-babel-tangle-file)
#+end_src

* Introduction

  [[https://gitlab.com/niklaseklund/dtache][Dtache]], or =Detach Emacs=, is a package to run and interact with shell commands which are run isolated from Emacs. The name of the package comes from [[https://github.com/crigler/dtach][dtach]], which is the program that makes this package possible.

  The inspiration for the package comes from those situations where I would chose to run commands in a terminal outside of Emacs.

  My reasons for not using Emacs at those points where:
  - performance
  - stability
  - remote support

* How to start a session?
** With M-x

A session can be started with the command =dtache-shell-command=.

#+begin_src elisp :results none
  (call-interactively #'dtache-shell-command)
#+end_src

** With a function

A session can also be started with the =dtache-start-session= function. Which can be included in custom commands.

#+begin_src elisp :results none :dir ~/code/python
  (dtache-start-session "pylint demo.py ")
#+end_src

** With shell

A session can also be started from =M-x shell=, making it a dispatcher for =dtache= sessions.

#+begin_src elisp :results none
  (call-interactively #'shell)
#+end_src

Run the following command.

#+begin_src sh
  /tmp/dtache/loop.sh && ls -la
#+end_src

* How to interact with a session?

To list all sessions.

#+begin_src elisp :results none
  (dtache-list-sessions)
#+end_src

The commands that are available.

| Command                       | Description                  | Keybinding |
|-------------------------------+------------------------------+------------|
| =dtache-open-session=         | A DWIM function              | Return     |
| =dtache-post-compile-session=      | Post compilation             | c          |
| =dtache-delete-session=       | Delete an active session     | d          |
| =dtache-kill-session=         | Kill an active session       | k          |
| =dtache-open-output=          | Open sessions output         | o          |
| =dtache-rerun-session=        | Rerun a session              | r          |
| =dtache-tail-session=         | Tail the output of a session | t          |
| =dtache-copy-session-command= | Copy command                 | w          |
| =dtache-copy-session-output=  | Copy the output              | W          |

* Configuration
** Annotators

An annotator function runs when a session is started. Its intent is to capture metadata information.

#+begin_src elisp :results none
  (defun dtache--session-git-branch ()
    "Return current git branch."
    (let ((git-directory (locate-dominating-file "." ".git")))
      (when git-directory
        (let ((args '("name-rev" "--name-only" "HEAD")))
          (with-temp-buffer
            (apply #'process-file `("git" nil t nil ,@args))
            (string-trim (buffer-string)))))))
#+end_src

Register the annotator function.

#+begin_src elisp :results none
  (setq dtache-metadata-annotators-alist '((branch . dtache--session-git-branch)))
#+end_src

Create a session.

#+begin_src elisp :results none :dir ~/src/emacs-packages/dtache
  (dtache-start-session "sleep 2 && ls")
#+end_src

** External package integration

Here are some examples on how =dtache= can be further improved with external packages.

*** Embark & Marginalia

The command =dtache-open-session= is an alternative to the =dtache-list-sessions=.

#+begin_src elisp :results none
  (call-interactively #'dtache-open-session)
#+end_src

The =dtache-open-session= can be enhanced with [[https://github.com/minad/marginalia/][marginalia]] annotations.

#+begin_src elisp :results none
  (use-package marginalia-dtache
    :after (dtache marginalia)
    :config
    (setq dtache-max-command-length 50)
    (add-to-list 'marginalia-annotator-registry '(dtache marginalia-dtache-annotate builtin none)))
#+end_src

The =dtache-open-session= can also be given actions through [[https://github.com/oantolin/embark/][embark]].

#+begin_src elisp :results none
  (use-package embark-dtache
    :after (dtache embark))
#+end_src

*** Alert

By default =dtache= uses the echo area to notify the user when a session has finished. An alternative is to utilize the [[https://github.com/jwiegley/alert][alert]] package to get a system notification instead.

#+begin_src elisp :results none
  (defun dtache-session-finish-alert (session)
    "Send an alert notification when SESSION finish."
    (let ((status (dtache--session-status session))
          (title
           (pcase (dtache--session-status session)
             ('success "Dtache finished!")
             ('failure "Dtache failed!"))))
      (alert (dtache--session-command session)
             :title title
             :severity (pcase status
                         ('success 'moderate)
                         ('failure 'high))
             :category 'compile
             :id (pcase status
                   ('success 'compile-ok)
                   ('failure 'compile-fail)))))

  (advice-add 'dtache-session-finish-notification :override #'dtache-session-finish-alert)
#+end_src

A successful session.

#+begin_src elisp :results none :dir ~/src/emacs-packages/dtache
  (dtache-start-session "ls")
#+end_src

A failing session.

#+begin_src elisp :results none :dir ~/src/emacs-packages/dtache
  (dtache-start-session "lsl")
#+end_src

* Other use cases
** Remote execution

=Dtache= has support for remote execution which is made possible through =TRAMP=. The only difference from a users perspective is that there might be some delay before the notification is issued. 

#+begin_src elisp :dir /ssh:pi:~/bin :results none
  (dtache-start-session "sleep 5 && ls -la")
#+end_src

** Duration

The duration becomes very valuable when the shell commands are deterministic.

** Diff two sessions

In combination with the =git-branch= annotator the =dtache-diff-session= command becomes useful in comparing two sessions.

#+begin_src elisp :results none
  (let ((window-conf))
    (add-hook 'ediff-before-setup-hook
              (defun demo/ediff-save-window-conf ()
                (setq window-conf (current-window-configuration))))
    (dolist (hook '(ediff-quit-hook ediff-suspended-hook))
      (add-hook hook (defun demo/ediff-restore-window-conf ()
                       (set-window-configuration window-conf)))))
#+end_src

** Transient combo

[[https://github.com/magit/transient][Transient]] and =dtache= plays very well together. At work I use the power of transient to compose shell commands and =dtache= to run them.

** Create sessions with custom open functions

Sometimes you need to tweak =dtache's= behavior in how to interact with specific sessions. If that is the case it is best done by adding a custom =open-function= or a custom =callback-function=.

#+begin_src elisp :results none
  (defun demo/dtache-custom-session (command)
    "Run COMMAND in a very custom way."
    (let ((dtache-open-session-function
           (lambda (session)
             (let ((buffer (get-buffer-create "*dtache-custom-open*")))
               (with-current-buffer buffer
                 (erase-buffer)
                 (insert "This is a custom view of the session\n")
                 (insert (dtache-session-output session)))
               (pop-to-buffer buffer)))))
      (dtache-start-session command)))

  (demo/dtache-custom-session "ls")
#+end_src

* The End 

The last thing we need to actually prove is the ability to actually run independently from Emacs.

Local session.

#+begin_src elisp :results none
  (dtache-start-session "/tmp/dtache/loop.sh && echo end")
#+end_src

Remote session.

#+begin_src elisp :dir /ssh:pi:~/bin :results none
  (dtache-start-session "sleep 30 && ls -la")
#+end_src

Thanks for watching :)
