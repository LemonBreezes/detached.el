#+title: dtache.el - Dtach Emacs
#+author: Niklas Eklund
#+language: en

* Introduction
  :properties:
  :description: Why Dtache?
  :end:

=Dtache=, or =Detach Emacs=, is a package to run shell commands completely detached from Emacs. With shell commands, we refer to commands that otherwise would be run in a terminal. The detachable nature of the package means that commands started with it can outlive Emacs, which also works on remote hosts, essentially offering a lightweight alternative to [[https://github.com/tmux/tmux][Tmux]] or [[https://www.gnu.org/software/screen/][GNU Screen]]. The user can effectively use =dtache= as a go to command for running =build= or =test= commands, which works well with =dtache's= automatic status labeling functionality.

The core concept of =dtache= is its object =dtache-session=. This object encapsulate information about a session, such as the =command= which is run in the session, the =working directory= from which the session is started, the =host= on which the session runs, where the =output= of the session is stored, where the =socket= to the underlying =dtach= process resides etc. The program [[https://github.com/crigler/dtach][dtach]] is what makes this package possible, it takes care of running the commands and =dtache= instructs what and how it should run it.

The following videos features demonstrations about the package:
- [[https://www.youtube.com/watch?v=if1W58SrClk][Dtache - An Emacs package that provides detachable shell commands]]
- [[https://www.youtube.com/watch?v=De5oXdnY5hY][Dtache - Version 0.2]]

** Features

The way =dtache= is designed with its =dtache-session= objects opens up the possibilities for the following features.

*** Output

The user always have access to the session's output. The user never needs to fear that the output history of the terminal is not enough to capture all of its output. Also its pretty handy to be able to go back in time and see the output from a session you ran earlier today. Also having access to the output as well as the other information from the session makes it possible to enable =compilation-minor-mode= in order to use Emacs built in capabilities of navigating between errors in the output. This is something =dtache= will do automatically if it detects that you are opening the output of a session with status =failure=.

*** Notifications

Start a session and then focus on something else. =Dtache= will notify you when the session has become inactive. For local sessions this is made possible through the built in =filenotify=.

*** Metadata

The session will include useful metadata such as when the session was started, for how long it has been running (if it is active), how long it ran (if it is inactive).

*** Annotations

Want to capture annotations about a session, if you run it within a specific project maybe you want to annotate the session with the current =git= branch, or any other custom annotation.

*** Remote

Proper support for running session on a remote host. With remote sessions the notifications are triggered using timers, which periodically check for updates on the remote sockets. This means the notification will not be instant for remote sessions.

*** Actions

The package provides commands that can act on a session. There is the functionality to =kill= an active session, to =rerun= a session, or =diff= two sessions.

*** Persistency

The sessions are made persistent by writing the objects to file. This makes it possible for Emacs to resume the knowledge of prior sessions when the program is restarted.

* Configuration

For the time being =dtache= is not available in any of the Emacs repositories. Therefore =dtache= must be installed from source. The prerequisite for =dtache= is that the user has the program =dtach= installed.

** Use-package example

A minimal configuration for =dtache=.

#+begin_src elisp :lexical t :results none
  (use-package dtache
    :hook (after-init . dtache-initialize)
    :bind (([remap async-shell-command] . dtache-shell-command)
           :map dtache-shell-mode-map
           ("C-c C-q" . dtache-detach-session))
    :config
    (setq dtache-db-directory user-emacs-directory)
    (setq dtache-session-directory (expand-file-name "dtache" (temporary-file-directory))))
#+end_src

* Commands
** Creating a session

There are tree different ways to create a dtache session.

| Function                      | Description                   |
|-------------------------------+-------------------------------|
| =dtache-shell-command=        | Called from M-x               |
| =dtache-start-session=        | Called from within a function |
| =dtache-shell-create-session= | Called from inside M-x shell  |

The =dtache-shell-command= is for the Emacs users that are accustomed to running shell commands from =M-x shell-command= or =M-x async-shell-command=. The =dtache-start-session= is supposed to be called from custom user functions, or for other packages to integrate towards. The user can also choose to override built in functions with it, for example =compile=. Lastly there is the =dtache-shell-create-session= command which is supposed to be bound to a key. It is a command that the user can choose to invoke whilst in a =M-x shell= buffer.

To detach from a session you started with =dtache-shell-command= you should bind the command =dtache-detach-session= to something convenient in the =dtache-shell-mode-map=.

** Interacting with a session

To interact with a session =dtache= provides the command =dtache-open-session=. This provides a convenient completion interface, enriched with annotations to provide useful information about the sessions. The =dtache-open-session= command is implemented as a do what I mean command. This results in =dtache= performing different actions depending on the state of a session.

- If the session has a =custom open function=, call that function
- If the session is =active=, tail its output
- If the session is inactive and has status =failure=, compile the output
- If the session is inactive and has status =success=, open the output

  The package also provides additional commands to interact with a session.

| Command (Keybinding)              | Description                                 |
|-----------------------------------+---------------------------------------------|
| dtache-open-output (o)            | Open a session's output                     |
| dtache-tail-output  (t)           | Tail the output of an active session        |
| dtache-diff-session (=)           | Diff a session with another session         |
| dtache-compile-session (c)        | Open the session output in compilation mode |
| dtache-rerun-session (r)          | Rerun a session                             |
| dtache-insert-session-command (i) | Insert the session's command at point       |
| dtache-copy-session-command (w)   | Copy the session's shell command            |
| dtache-copy-session-output (W)    | Copy the session's output                   |
| dtache-kill-session (k)           | Kill an active session                      |
| dtache-delete-session (d)         | Delete an inactive session                  |

These commands are available through the =dtache-action-map=. The user can bind the action map to a keybinding of choice. For example

#+begin_src elisp :lexical t :results none
  (global-set-key (kbd "C-c d") dtache-action-map)
#+end_src

The upon invocation the user can choose an action, keybindings listed in the table above, and then choose a session to perform the action upon.

* Extensions
** Dtache-shell

A =use-package= configuration of the =dtache-shell= package. This package provides the integration with =M-x shell=, but since not all Emacs users use =shell=, this package is made optional.

#+begin_src elisp :lexical t :results none
  (use-package dtache-shell
    :hook (after-init . dtache-shell-setup)
    :bind (:map dtache-shell-mode-map
           (("<S-return>" . dtache-shell-create-session)
            ("<C-return>" . dtache-shell-attach)))
    :config
    (setq dtache-shell-history-file "~/.bash_history"))
#+end_src

These are commands that the package provides and which the user is expected to bind to convenient keys. The =dtache= package provides a minor mode named =dtache-shell-mode=, which will be enabled in shell.

| Command             | Description           |
|---------------------+-----------------------|
| dtache-shell-create | Create a session      |
| dtache-shell-attach | Attach to a session   |

To detach from a session use the command =dtache-detach-session=. As instructed earlier you can bind this command in the =dtache-shell-mode-map=.

** Dtache-eshell

A =use-package= configuration of the =dtache-eshell= package. This package provides the integration with =eshell=, but since not all Emacs users use =eshell=, this package is made optional.

#+begin_src elisp :lexical t :results none
  (use-package dtache-eshell
    :hook (after-init . dtache-eshell-setup)
    :bind (:map dtache-eshell-mode-map
           (("<S-return>" . dtache-eshell-create-session)
            ("<C-return>" . dtache-eshell-attach)
            ("C-c C-q" . dtache-detach-session))))
#+end_src

These are commands that the package provides and which the user is expected to bind to convenient keys. The package provides a minor mode that will be enabled in =eshell=.

| Command                      | Description         |
|------------------------------+---------------------|
| dtache-eshell-create-session | Create a session    |
| dtache-eshell-attach         | Attach to a session |

To detach from a session simply use =C-c C-c=. In this [[https://niklaseklund.gitlab.io/blog/posts/dtache_eshell/][blog post]] there are examples and more information about the extension.

** TODO Compile

Add text here.

#+begin_src elisp
  (use-package dtache-compile
    :hook (after-init . dtache-compile-setup)
    :bind (([remap compile] . dtache-compile)
           ([remap recompile] . dtache-compile-recompile)
           :map dtache-compilation-mode-map
           ("C-c C-q" . dtache-detach-session)))
#+end_src

** Consult

A =use-package= configuration of the =dtache-consult= package. This package provides the integration with the [[https://github.com/minad/consult][consult]] package.

#+begin_src elisp
  (use-package dtache-consult
    :commands dtache-consult-session)
#+end_src

This package provides the =dtache-consult-session= command which is a replacement for =dtache-open-session=. The difference is that the consult command provides multiple session sources, which is defined in the =dtache-consult-sources= variable. Users can customize which sources to use, as well as use individual sources in other =consult= commands, such as =consult-buffer=. The users can also narrow the list of sessions by entering a key. The list of supported keys are:

| Type                  | Key |
|-----------------------+-----|
| Active sessions       | a   |
| Inactive sessions     | i   |
| Successful sessions   | s   |
| Failed sessions       | f   |
| Local host sessions   | l   |
| Remote host sessions  | r   |
| Current host sessions | c   |

Examples of the different sources are featured in this [[https://niklaseklund.gitlab.io/blog/posts/dtache_consult/][blog post]].

** Embark

The user have the possibility to integrate =dtache= with the package [[https://github.com/oantolin/embark/][embark]]. The =dtache-action-map= can be reused for this purpose, so the user doesn't need to bind it to any key. Instead the user simply adds the following to their =dtache= configuration in order to get embark actions for =dtache-open-session=.

#+begin_src elisp :lexical t :results none
  (defvar embark-dtache-map (make-composed-keymap dtache-action-map embark-general-map))
  (add-to-list 'embark-keymap-alist '(dtache . embark-dtache-map))
#+end_src

** Alert

By default =dtache= uses the echo area to notify the user when a session has finished. An alternative is to utilize the [[https://github.com/jwiegley/alert][alert]] package to get a system notification instead.

#+begin_src elisp :lexical t :results none
  (defun my/dtache-inactive-session-notification (session)
    "Send an `alert' notification when SESSION becomes inactive."
    (let ((status (dtache--session-status session))
          (title
           (pcase (dtache--session-status session)
             ('success "Dtache finished!")
             ('failure "Dtache failed!"))))
      (alert (dtache--session-command session)
             :title title
             :severity (pcase status
                         ('success 'moderate)
                         ('failure 'high))
             :category 'compile
             :id (pcase status
                   ('success 'dtache-success)
                   ('failure 'dtache-failure)))))

  (setq dtache-notification-function #'my/dtache-inactive-session-notification)
#+end_src

* Customization
** Completion annotations

The user can customize the appearance of annotations in =dtache-open-session= by modifying the =dtache-annotation-format=. The default annotation format is the following.

#+begin_src elisp :results none
  (defvar dtache-annotation-format
    `((:width 3 :function dtache--active-str :face dtache-active-face)
      (:width 3 :function dtache--status-str :face dtache-failure-face)
      (:width 10 :function dtache--session-host :face dtache-host-face)
      (:width 40 :function dtache--working-dir-str :face dtache-working-dir-face)
      (:width 30 :function dtache--metadata-str :face dtache-metadata-face)
      (:width 10 :function dtache--duration-str :face dtache-duration-face)
      (:width 8 :function dtache--size-str :face dtache-size-face)
      (:width 12 :function dtache--creation-str :face dtache-creation-face))
    "The format of the annotations.")
#+end_src

If the user wants to remove specific annotations or decrease/increase the widths, do that by changing the values for this variable.

** Automatic status labeling

The =dtache-env= script, found in this repository, can be used to execute shell commands in a controlled environment. This environment makes sure that the exit status is present in the session's output. This allows =dtache= to parse it and automatically label a session with either =success= or =failure=.

Add the following to the configuration in order to take advantage of this feature.

#+begin_src elisp :lexical t :results none
  (setq dtache-env "/path/to/repo/dtache-env")
#+end_src

** Metadata annotators

The user can configure any number of annotators to run upon creation of a session. Here is an example of an annotator which captures the branch name if the session is started in a git repository.

#+begin_src elisp :lexical t :results none
  (defun my/dtache--session-git-branch ()
    "Return current git branch."
    (let ((git-directory (locate-dominating-file "." ".git")))
      (when git-directory
        (let ((args '("name-rev" "--name-only" "HEAD")))
          (with-temp-buffer
            (apply #'process-file `("git" nil t nil ,@args))
            (string-trim (buffer-string)))))))
#+end_src

The user only needs to add this function to the list of annotators.

#+begin_src elisp :lexical t :results none
  (setq dtache-metadata-annotators-alist '((branch . my/dtache--session-git-branch))
#+end_src

** Redirect only

Some programs doesn't play well with =tee=, which =dtache= relies upon to redirect the output both to standard out as well as to file. If you encounter a situation where output from a session is only visible once it has become inactive, the command you launched should instead be using =redirect only=. To list a command to run with redirect only can be done by adding a regexp to =dtache-redirect-only-regexps=.

#+begin_src elisp :lexical t :results none
  (setq dtache-redirect-only-regexps '("^ls"))
#+end_src

Here a command beginning with =ls= would from now on be using redirect only.
* Tips & Tricks
** Remote support

The =dtache= package supports [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Connection-Local-Variables.html][Connection Local Variables]] which allows you to change the variables used by =dtache= when running on a remote host. This useful when the user needs to alter dtache settings when running on a remote host.

#+begin_src elisp :lexical t :results none
  (connection-local-set-profile-variables
   'remote-dtache
   '((dtache-env . "~/bin/dtache-env")
     (dtache-shell-program . "/bin/bash")
     (dtache-shell-history-file . "~/.bash_history")
     (dtache-session-directory . "~/tmp")
     (dtache-dtach-program . "/home/user/.local/bin/dtach")))

  (connection-local-set-profiles
   '(:application tramp :protocol "ssh") 'remote-dtache)
#+end_src
** Enhance a command with dtache

A part from the extensions provided with this package the users of =dtache= can leverage the package to instruct other commands to use =dtache=. Here is an example where the package =dired-rsync= is modified to utilize =dtache=.

#+begin_src elisp
  (defun my/dtache-dired-rsync-advice (orig-fun &rest args)
    "Always run `dired-rsync' with `dtache'."
    (pcase-let* ((`(,command ,details) args)
                 (dtache--dtach-mode 'new))
      (apply orig-fun `(,(dtache-dtach-command command t) ,details))))

  (advice-add #'dired-rsync--do-run :around #'my/dtache-dired-rsync-advice)
#+end_src

** Customize an individual session

=Dtache= tries to leave possibilities for the users to customize the usage. One key feature is that the customization can happen on session level. Meaning that the user can choose to customize a session right before it is started. The customization will then be embedded into the session object and persist for as long as the session exists.

#+begin_src elisp :lexical t :dir ~/code/python :results none
  (defun my/dtache-custom-open-session (command)
    "Run COMMAND in a session and control how it should be opened."
    (let ((dtache-open-session-function
           (lambda (session)
             (let ((dtache-compile-hooks
                    `(,@dtache-compile-hooks
                      ,(lambda ()
                         (make-variable-buffer-local 'compilation-parse-errors-function)
                         (setq compilation-parse-errors-filename-function
                               (lambda (_)
                                 (format "~/.bashrc")))))))
               (dtache-open-dwim session)))))
      (dtache-start-session command)))

  (demo/dtache-custom-session "pylint demo.py")
#+end_src

The example in the code block is creating a custom open function that will modify the =compilation-parse-errors-function= and set it locally in the buffer that will be opened with =dtache-compile-session=. In the example regardless of what errors pylint manages to find the links in the compile buffer will all open =~/.bashrc=. This customization only affects the sessions that are started with the =my/dtache-custom-open-session=.

The user also have the same possibility of customization when it comes to the variables =dtache-session-callback-function= and =dtache-session-status-function=.

* Versions

Information about the changes to the package can be found in the =CHANGELOG.org=.

* Contributions

For the time being I try to keep the possibility open to submit the package to [[https://elpa.gnu.org/][ELPA]], which means that if you want to contribute you should have gone through the copyright assignment procedure.

* Credits

I got inspired by =Ambrevar's= pursuits on [[https://ambrevar.xyz/emacs-eshell/][using eshell as his main shell]], and his [[https://github.com/Ambrevar/dotfiles/blob/master/.emacs.d/lisp/package-eshell-detach.el][package-eshell-detach]] got me into the idea of using =dtach= as a base for detachable shell commands.
