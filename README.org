#+title: dtache.el - Dtach Emacs
#+author: Niklas Eklund
#+language: en

* Introduction
  :properties:
  :description: Why Dtache?
  :end:

=Dtache=, or =Detach Emacs=, is a package to run shell commands completely detached from Emacs. With shell commands, we refer to commands that otherwise would be run in a terminal. The detachable nature of the package means that commands started with it can outlive Emacs, which also works on remote hosts, essentially offering a lightweight alternative to [[https://github.com/tmux/tmux][Tmux]] or [[https://www.gnu.org/software/screen/][GNU Screen]]. The user can effectively use =dtache= as a go to command for running =build= or =test= commands, which works well with =dtache's= automatic status labeling functionality.

The core concept of =dtache= is its object =dtache-session=. This object encapsulate information about a session, such as the =command= which is run in the session, the =working directory= from which the session is started, the =host= on which the session runs, where the =output= of the session is stored, where the =socket= to the underlying =dtach= process resides etc. The program [[https://github.com/crigler/dtach][dtach]] is what makes this package possible, it takes care of running the commands and =dtache= instructs what and how it should run it.

The following videos features demonstrations about the package:
- [[https://www.youtube.com/watch?v=if1W58SrClk][Dtache - An Emacs package that provides detachable shell commands]]
- [[https://www.youtube.com/watch?v=De5oXdnY5hY][Dtache - Version 0.2]]

** Features

The way =dtache= is designed with its =dtache-session= objects opens up the possibilities for the following features.

*** Output

The user always have access to the session's output. The user never needs to fear that the output history of the terminal is not enough to capture all of its output. Also its pretty handy to be able to go back in time and see the output from a session you ran earlier today. Also having access to the output as well as the other information from the session makes it possible to enable =compilation-minor-mode= in order to use Emacs built in capabilities of navigating between errors in the output. This is something =dtache= will do automatically if it detects that you are opening the output of a session with status =failure=.

*** Notifications

Start a session and then focus on something else. =Dtache= will notify you when the session has become inactive. For local sessions this is made possible through the built in =filenotify=.

*** Metadata

The session will include useful metadata such as when the session was started, for how long it has been running (if it is active), how long it ran (if it is inactive).

*** Annotations

Want to capture annotations about a session, if you run it within a specific project maybe you want to annotate the session with the current =git= branch, or any other custom annotation.

*** Remote

Proper support for running session on a remote host. With remote sessions the notifications are triggered using timers, which periodically check for updates on the remote sockets. This means the notification will not be instant for remote sessions.

*** Actions

The package provides commands that can act on a session. There is the functionality to =kill= an active session, to =rerun= a session, or =diff= two sessions.

*** Persistency

The sessions are made persistent by writing the objects to file. This makes it possible for Emacs to resume the knowledge of prior sessions when the program is restarted.

* Configuration

For the time being =dtache= is not available in any of the Emacs repositories. Therefore =dtache= must be installed from source. The prerequisite for =dtache= is that the user has the program =dtach= installed.

** Use-package example

A minimal configuration for =dtache=.

#+begin_src elisp :lexical t :results none
  (use-package dtache
    :hook (after-init . dtache-initialize)
    :bind (([remap async-shell-command] . dtache-shell-command)
           :map dtache-shell-mode-map
           ("C-c C-q" . dtache-detach-session))
    :config
    (setq dtache-db-directory user-emacs-directory)
    (setq dtache-session-directory (expand-file-name "dtache" (temporary-file-directory))))
#+end_src

* Commands
** Creating a session

There are tree different ways to create a dtache session.

| Function                       | Description                   |
|--------------------------------+-------------------------------|
| =dtache-shell-command=         | Called from M-x               |
| =dtache-shell-create-session=  | Called from inside M-x shell  |
| =dtache-eshell-create-session= | Called from inside eshell     |
| =dtache-compile=               | Called from M-x               |
| =dtache-start-session=         | Called from within a function |

The =dtache-shell-command= is for the Emacs users that are accustomed to running shell commands from =M-x shell-command= or =M-x async-shell-command=. The =dtache-start-session= is supposed to be called from custom user functions, or for other packages to integrate towards. The user can also choose to override built in functions with it, for example =compile=. Lastly there is the =dtache-shell-create-session= command which is supposed to be bound to a key. It is a command that the user can choose to invoke whilst in a =M-x shell= buffer.

To detach from a =dtache= session you should use the univeral =dtache-detach-session=.

** Interacting with a session

To interact with a session =dtache= provides the command =dtache-open-session=. This provides a convenient completion interface, enriched with annotations to provide useful information about the sessions. The =dtache-open-session= command is implemented as a do what I mean command. This results in =dtache= performing different actions depending on the state of a session.

- If the session has a =custom open function=, call that function
- If the session is =active=, tail its output
- If the session is inactive and has status =failure=, compile the output
- If the session is inactive and has status =success=, open the output

  The package also provides additional commands to interact with a session.

| Command (Keybinding)              | Description                                 |
|-----------------------------------+---------------------------------------------|
| dtache-open-output (o)            | Open a session's output                     |
| dtache-tail-output  (t)           | Tail the output of an active session        |
| dtache-diff-session (=)           | Diff a session with another session         |
| dtache-compile-session (c)        | Open the session output in compilation mode |
| dtache-rerun-session (r)          | Rerun a session                             |
| dtache-insert-session-command (i) | Insert the session's command at point       |
| dtache-copy-session-command (w)   | Copy the session's shell command            |
| dtache-copy-session-output (W)    | Copy the session's output                   |
| dtache-kill-session (k)           | Kill an active session                      |
| dtache-delete-session (d)         | Delete an inactive session                  |

These commands are available through the =dtache-action-map=. The user can bind the action map to a keybinding of choice. For example

#+begin_src elisp :lexical t :results none
  (global-set-key (kbd "C-c d") dtache-action-map)
#+end_src

Then upon invocation the user can choose an action, keybindings listed in the table above, and then choose a session to perform the action upon.

* Extensions
** Dtache-shell

A =use-package= configuration of the =dtache-shell= extension, which provides the integration with =M-x shell=.

#+begin_src elisp :lexical t :results none
  (use-package dtache-shell
    :hook (after-init . dtache-shell-setup)
    :bind (:map dtache-shell-mode-map
           (("<S-return>" . dtache-shell-create-session)
            ("<C-return>" . dtache-shell-attach)))
    :config
    (setq dtache-shell-history-file "~/.bash_history"))
#+end_src

A minor mode named =dtache-shell-mode= is provided, and will be enabled in =shell=. The commands that are implemented are:

| Command               | Description           |
|-----------------------+-----------------------|
| dtache-shell-create   | Create a session      |
| dtache-shell-attach   | Attach to a session   |
| dtache-detach-session | Detach from a session |

** Dtache-eshell

A =use-package= configuration of the =dtache-eshell= extension, which provides the integration with =eshell=.

#+begin_src elisp :lexical t :results none
  (use-package dtache-eshell
    :hook (after-init . dtache-eshell-setup)
    :bind (:map dtache-eshell-mode-map
           (("<S-return>" . dtache-eshell-create-session)
            ("<C-return>" . dtache-eshell-attach)
            ("C-c C-q" . dtache-detach-session))))
#+end_src

A minor mode named =dtache-eshell-mode= is provided, and will be enabled in =eshell=. The commands that are implemented are:

| Command                      | Description           |
|------------------------------+-----------------------|
| dtache-eshell-create-session | Create a session      |
| dtache-eshell-attach         | Attach to a session   |
| dtache-detach-session        | Detach from a session |

In this [[https://niklaseklund.gitlab.io/blog/posts/dtache_eshell/][blog post]] there are examples and more information about the extension.

** Compile

A =use-package= configuration of the =dtache-compile= extension, which provides the integration with =compile=.

#+begin_src elisp
  (use-package dtache-compile
    :hook (after-init . dtache-compile-setup)
    :bind (([remap compile] . dtache-compile)
           ([remap recompile] . dtache-compile-recompile)
           :map dtache-compilation-mode-map
           ("C-c C-q" . dtache-detach-session)))
#+end_src

The package implements the commands =dtache-compile= and =dtache-compile-recompile=, which are thin wrappers around the original =compile= and =recompile= commands. The users should be able to use the former as replacements for the latter without noticing any difference except from the possibility to =detach=.

** Consult

A =use-package= configuration of the =dtache-consult= extension, which provides the integration with the [[https://github.com/minad/consult][consult]] package.

#+begin_src elisp
  (use-package dtache-consult
    :commands dtache-consult-session)
#+end_src

The command =dtache-consult-session= is a replacement for =dtache-open-session=. The difference is that the consult command provides multiple session sources, which is defined in the =dtache-consult-sources= variable. Users can customize which sources to use, as well as use individual sources in other =consult= commands, such as =consult-buffer=. The users can also narrow the list of sessions by entering a key. The list of supported keys are:

| Type                  | Key |
|-----------------------+-----|
| Active sessions       | a   |
| Inactive sessions     | i   |
| Successful sessions   | s   |
| Failed sessions       | f   |
| Local host sessions   | l   |
| Remote host sessions  | r   |
| Current host sessions | c   |

Examples of the different sources are featured in this [[https://niklaseklund.gitlab.io/blog/posts/dtache_consult/][blog post]].

** 3rd party
*** Embark

The user have the possibility to integrate =dtache= with the package [[https://github.com/oantolin/embark/][embark]]. The =dtache-action-map= can be reused for this purpose, so the user doesn't need to bind it to any key. Instead the user simply adds the following to their =dtache= configuration in order to get embark actions for =dtache-open-session=.

#+begin_src elisp :lexical t :results none
  (defvar embark-dtache-map (make-composed-keymap dtache-action-map embark-general-map))
  (add-to-list 'embark-keymap-alist '(dtache . embark-dtache-map))
#+end_src

*** Alert

By default =dtache= uses the echo area to notify the user when a session has finished. An alternative is to utilize the [[https://github.com/jwiegley/alert][alert]] package to get a system notification instead.

#+begin_src elisp :lexical t :results none
  (defun my/dtache-inactive-session-notification (session)
    "Send an `alert' notification when SESSION becomes inactive."
    (let ((status (dtache--session-status session))
          (title
           (pcase (dtache--session-status session)
             ('success "Dtache finished!")
             ('failure "Dtache failed!"))))
      (alert (dtache--session-command session)
             :title title
             :severity (pcase status
                         ('success 'moderate)
                         ('failure 'high))
             :category 'compile
             :id (pcase status
                   ('success 'dtache-success)
                   ('failure 'dtache-failure)))))

  (setq dtache-notification-function #'my/dtache-inactive-session-notification)
#+end_src

* Customization
** Completion annotations

The user can customize the appearance of annotations in =dtache-open-session= by modifying the =dtache-annotation-format=. The default annotation format is the following.

#+begin_src elisp :results none
  (defvar dtache-annotation-format
    `((:width 3 :function dtache--active-str :face dtache-active-face)
      (:width 3 :function dtache--status-str :face dtache-failure-face)
      (:width 10 :function dtache--session-host :face dtache-host-face)
      (:width 40 :function dtache--working-dir-str :face dtache-working-dir-face)
      (:width 30 :function dtache--metadata-str :face dtache-metadata-face)
      (:width 10 :function dtache--duration-str :face dtache-duration-face)
      (:width 8 :function dtache--size-str :face dtache-size-face)
      (:width 12 :function dtache--creation-str :face dtache-creation-face))
    "The format of the annotations.")
#+end_src

If the user wants to remove specific annotations or decrease/increase the widths, do that by changing the values for this variable.

** Automatic status labeling

The =dtache-env= script, found in this repository, can be used to execute shell commands in a controlled environment. This environment makes sure that the exit status is present in the session's output. This allows =dtache= to parse it and automatically label a session with either =success= or =failure=.

Add the following to the configuration in order to take advantage of this feature.

#+begin_src elisp :lexical t :results none
  (setq dtache-env "/path/to/repo/dtache-env")
#+end_src

** Metadata annotators

The user can configure any number of annotators to run upon creation of a session. Here is an example of an annotator which captures the branch name if the session is started in a git repository.

#+begin_src elisp :lexical t :results none
  (defun my/dtache--session-git-branch ()
    "Return current git branch."
    (let ((git-directory (locate-dominating-file "." ".git")))
      (when git-directory
        (let ((args '("name-rev" "--name-only" "HEAD")))
          (with-temp-buffer
            (apply #'process-file `("git" nil t nil ,@args))
            (string-trim (buffer-string)))))))
#+end_src

The user only needs to add this function to the list of annotators.

#+begin_src elisp :lexical t :results none
  (setq dtache-metadata-annotators-alist '((branch . my/dtache--session-git-branch))
#+end_src

** Redirect only

Some programs doesn't play well with =tee=, which =dtache= relies upon to redirect the output both to standard out as well as to file. If you encounter a situation where output from a session is only visible once it has become inactive, the command you launched should instead be using =redirect only=. To list a command to run with redirect only can be done by adding a regexp to =dtache-redirect-only-regexps=.

#+begin_src elisp :lexical t :results none
  (setq dtache-redirect-only-regexps '("^ls"))
#+end_src

Here a command beginning with =ls= would from now on be using redirect only.
* Tips & Tricks
** Remote support

The =dtache= package supports [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Connection-Local-Variables.html][Connection Local Variables]] which allows you to change the variables used by =dtache= when running on a remote host. This useful when the user needs to alter dtache settings when running on a remote host.

#+begin_src elisp :lexical t :results none
  (connection-local-set-profile-variables
   'remote-dtache
   '((dtache-env . "~/bin/dtache-env")
     (dtache-shell-program . "/bin/bash")
     (dtache-shell-history-file . "~/.bash_history")
     (dtache-session-directory . "~/tmp")
     (dtache-dtach-program . "/home/user/.local/bin/dtach")))

  (connection-local-set-profiles
   '(:application tramp :protocol "ssh") 'remote-dtache)
#+end_src
** Enhance a command with dtache

A part from the extensions provided with this package the users of =dtache= can leverage the package to instruct other commands to use =dtache=. Here is an example with a command from the package [[https://github.com/stsquad/dired-rsync][dired-rsync]].

#+begin_src elisp
  (defun my/dtache-dired-rsync ()
    "Run `dired-rsync' with `dtache'."
    (interactive)
    (let* ((dtache-enabled t)
           (dtache--dtach-mode 'new))
      (call-interactively #'dired-rsync)))
#+end_src

Or enhancing the built in =dired-do-async-shell-command=.

#+begin_src elisp
  (defun my/dtache-dired-do-async-shell-command ()
    (interactive)
    (let* ((dtache-enabled t)
           (dtache--dtach-mode 'create))
      (call-interactively #'dired-do-async-shell-command)))
#+end_src

* Versions

Information about the changes to the package can be found in the =CHANGELOG.org=.

* Contributions

For the time being I try to keep the possibility open to submit the package to [[https://elpa.gnu.org/][ELPA]], which means that if you want to contribute you should have gone through the copyright assignment procedure.

* Credits

I got inspired by =Ambrevar's= pursuits on [[https://ambrevar.xyz/emacs-eshell/][using eshell as his main shell]], and his [[https://github.com/Ambrevar/dotfiles/blob/master/.emacs.d/lisp/package-eshell-detach.el][package-eshell-detach]] got me into the idea of using =dtach= as a base for detachable shell commands.
