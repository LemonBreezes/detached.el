#+title: dtache.el - Dtach Emacs
#+author: Niklas Eklund
#+language: en

* Introduction
  :properties:
  :description: Why Dtache?
  :end:

  =Dtache=, or =Detach Emacs=, is a package to run shell commands in sessions that are isolated from Emacs. =Dtache= also provides a convenient user interface to interact with the sessions. 

  The package sprung out of the realization that I would run certain shell commands in a terminal outside of Emacs instead of using =M-x shell=. These situations were I didn't choose Emacs was either:
  - Because of performance reasons, the built in shell is not the fastest when there is a lot of output
  - Because of stability concerns, I didn't want to have Emacs freeze or crash have an effect on the shell command I was running
  - Because of remote capabilities, I would be using [[https://github.com/tmux/tmux][Tmux]] on a remote host in order to run a command and detach from it
  But running shell commands outside of Emacs meant missing out on all the nice features that comes from an Emacs workflow.
 
  The solution for me has been =dtache=. The package allows users to start sessions, which will keep on running, even if Emacs itself is shut down. This is a feature provided by the program [[https://github.com/crigler/dtach][dtach]]. The package takes all of the previous benefits of using an external terminal and provides them in the package and at the same time offers a lot of other capabilities, provided by Emacs.

** Features

Here is a list of features that =dtache= provides for a session.

  - =Output=: The user have access to all output from a session
  - =Notification=: The user gets a notification when a session has finished
  - =Status=: Sessions are automatically labeled success or failure
  - =Remote=: Sessions can be started on remote hosts, effectively becoming a lightweight alternative to Tmux
  - =Duration=: The user is informed about for how long a session has run, or ran, if the session has finished
  - =Compile=: The user can choose to compile the output from a session, which effectively mimics =M-x compile=
  - =Tail=: The user can choose to tail the output of an active session
  - =Metadata=: The user can add annotators which are used to capture metadata about the environment from which the session was started
  - =Diff=: The user can compare two sessions in order to see differences in the session outputs
  - =Rerun=: The user can choose to rerun a session, which will rerun the command on the right host, in the correct working directory
  - =Open=: The user can quickly open a session in a Do What I Mean fashion:
    + If the session is active the output is tailed
    + If the session has the status success the output is opened
    + If the session has the status failure the session is compiled

  To see examples of the features listed above please see the following [[https://www.youtube.com/watch?v=if1W58SrClk][video]].
  
* Configuration
** Dtache

A minimal configuration for =dtache=.

#+begin_src elisp
  (use-package dtache
    :hook (after-init . dtache-initialize)
    :config
    ;; Configure `dtache'
    (setq dtache-db-directory user-emacs-directory)
    (setq dtache-session-directory (expand-file-name "dtache" (temporary-file-directory))))
#+end_src

* Commands
** Creating a session

There are tree different ways to create a dtache session.

| Function                      | Description                 |
|-------------------------------+-----------------------------|
| =dtache-shell-command=        | Call with  M-x              |
| =dtache-start-session=        | Call from within a function |
| =dtache-shell-create-session= | Call from inside M-x shell  |

** List sessions

There are two convenient ways of listing sessions and acting upon one.

| Function               | Description                     |
|------------------------+---------------------------------|
| =dtache-list-sessions= | Tabulated list view of sessions |
| =dtache-open-session=  | Completion based selection      |

** Actions on sessions

Session commands that can be used in either =dtache-list-sessions= or in =dtache-open-session=.

| Command                       | Description                                 |
|-------------------------------+---------------------------------------------|
| dtache-open-output            | Open a session's output                     |
| dtache-tail-output            | Tail the output of an active session        |
| dtache-diff-session           | Diff a session with another session         |
| dtache-compile-session        | Open the session output in compilation mode |
| dtache-rerun-session          | Rerun a session                             |
| dtache-insert-session-command | Insert the session's command at point       |
| dtache-copy-session-command   | Copy the session's shell command            |
| dtache-copy-session-output    | Copy the session's output                   |
| dtache-kill-session           | Kill an active session                      |
| dtache-remove-session         | Remove an inactive session                  |

* Extensions
** Dtache-shell

Configuration for the =dtache-shell= package. This package provides the integration with =M-x shell=.

#+begin_src elisp
  (use-package dtache-shell
    :hook (after-init . dtache-shell-setup)
    :general
    (:keymaps 'dtache-shell-mode-map
              "<S-return>" #'dtache-shell-create-session
              "<C-return>" #'dtache-shell-attach)
    :config
    (setq dtache-shell-history-file "~/.bash_history"))
#+end_src

Commands to be used in shell buffers.

| Command                 | Description                 |
|-------------------------+-----------------------------|
| dtache-shell-create     | Create a session            |
| dtache-shell-attach     | Attach to a session         |
| dtache-shell-detach     | Detach from a session       |
* Variables

** Annotations

The user can customize the appearance of annotations in =dtache-open-session= by modifying the =dtache-annotation-format=. The default annotation format is the following.

#+begin_src elisp
  (defvar dtache-annotation-format
    `((:width 3 :function dtache--active-str :face dtache-active-face)
      (:width 3 :function dtache--status-str :face dtache-failure-face)
      (:width 10 :function dtache--session-host :face dtache-host-face)
      (:width 40 :function dtache--working-dir-str :face dtache-working-dir-face)
      (:width 30 :function dtache--metadata-str :face dtache-metadata-face)
      (:width 10 :function dtache--duration-str :face dtache-duration-face)
      (:width 8 :function dtache--size-str :face dtache-size-face)
      (:width 12 :function dtache--creation-str :face dtache-creation-face))
    "The format of the annotations.")
#+end_src

If the user wants to remove specific annotations or decrease/increase the widths, do that by changing the values for this variable.

* Tips & Tricks
** Actions

To act on sessions the user can either bind the =dtache-action-map= to a binding of there choice. An example could be.

#+begin_src elisp
  (global-set-key (kbd "C-c d") dtache-action-map)
#+end_src

Or if the user has the package [[https://github.com/oantolin/embark/][embark]] installed the actions could be integrated with that package by adding the following to the =dtache= configuration.

#+begin_src elisp
  (defvar embark-dtache-map (make-composed-keymap dtache-action-map embark-general-map))
  (add-to-list 'embark-keymap-alist '(dtache . embark-dtache-map))
#+end_src

** Automatic status labeling

The =dtache-env= script found in this repository can be used to execute shell commands in a controlled environment. This environment makes sure that the exit status is present in the session's output. This makes it possible for =dtache= to automatically label a session with either =success= or =failure=.

Add the following to the configuration in order to take advantage of this feature.

#+begin_src elisp
  (setq dtache-env "/path/to/dtache-env")
#+end_src

** MacOS support

=Dtache= depends on =filenotify= to trigger events when a =dtach socket= is deleted, which defines the transition from active to inactive for a dtache session. Currently this implementation causes issues for MacOS users, it should work, but until the root cause has been identified this provides a workaround solution.

#+begin_src elisp
  (defun dtache--add-end-of-session-notification-advice (session)
    "Trigger an event when SESSION transition to inactive."
    (let ((dtache-timer-configuration
           '(:seconds 0.5 :repeat 0.5 :function run-with-idle-timer)))
      (dtache--session-timer session)))

  (advice-add 'dtache--add-end-of-session-notification :override #'dtache--add-end-of-session-notification-advice)
#+end_src

We replace the notification function with one based on a timer instead. This timer will periodically check if a session has gotten deactivated.

** System notifications

By default =dtache= uses the echo area to notify the user when a session has finished. An alternative is to utilize the [[https://github.com/jwiegley/alert][alert]] package to get a system notification instead.

#+begin_src elisp
  (defun dtache-session-finish-alert (session)
    "Send an alert notification when SESSION finish."
    (let ((status (dtache--session-status session))
          (title
           (pcase (dtache--session-status session)
             ('success "Dtache finished!")
             ('failure "Dtache failed!"))))
      (alert (dtache--session-command session)
             :title title
             :severity (pcase status
                         ('success 'moderate)
                         ('failure 'high))
             :category 'compile
             :id (pcase status
                   ('success 'compile-ok)
                   ('failure 'compile-fail)))))
#+end_src

With the usage of =advice= the user can override the default implantation with the alert version.

#+begin_src elisp
  (advice-add 'dtache-session-finish-notification :override #'dtache-session-finish-alert)
#+end_src
** Metadata annotators

The user can configure any number of annotators to run upon creation of a session. Here is an example of an annotator which captures the branch name if the session is started in a git repository.

#+begin_src elisp
  (defun dtache--session-git-branch ()
    "Return current git branch."
    (let ((git-directory (locate-dominating-file "." ".git")))
      (when git-directory
        (let ((args '("name-rev" "--name-only" "HEAD")))
          (with-temp-buffer
            (apply #'process-file `("git" nil t nil ,@args))
            (string-trim (buffer-string)))))))
#+end_src

The user only needs to add this function to the list of annotators.

#+begin_src elisp
  (setq dtache-metadata-annotators-alist '((branch . dtache--session-git-branch))
#+end_src

** Remote support

The =dtache= package supports [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Connection-Local-Variables.html][Connection Local Variables]] which allows you to change the variables used by =dtache= when running on a remote host. This useful when the user needs to alter dtache settings when running on a remote host.

#+begin_src elisp
  (connection-local-set-profile-variables
   'remote-dtache
   '((dtache-env . "~/bin/dtache-env")
     (dtache-shell-program . "/bin/bash")
     (dtache-shell-history-file . "~/.bash_history")
     (dtache-session-directory . "~/tmp")
     (dtache-dtach-program . "/home/user/.local/bin/dtach")))

  (connection-local-set-profiles
   '(:application tramp :protocol "ssh") 'remote-dtache)
#+end_src

** Redirect only

Some programs doesn't play well with =tee= which =dtache= relies upon to redirect the output both to standard out as well as to file. If you encounter a situation where output from a session is only visible once it has finished running, the command you launched should instead be using =redirect only=. To list a command to run with redirect only in the future can be done by adding a regexp to =dtache-redirect-only-regexps=.

#+begin_src elisp
  (setq dtache-redirect-only-regexps '("^ls"))
#+end_src

Here the command beginning with =ls= would from now on be using redirect only.

** Replace compile with dtache

*** Unconditionally

=Dtache= can be seen as a replacement for =compile=. To unconditionally replace the latter with the former one can apply this advice.

#+begin_src elisp
  (defun dtache-compile-override (command &optional _)
    "Run COMMAND with `dtache'."
    (dtache-start-session command))

  (advice-add 'compile :override #'dtache-compile-override)
#+end_src

#+RESULTS:

*** Selectively

Maybe you like the behavior of =compile= but for some specific commands you would like to replace the usage of =compile= with =dtache=. That can be done with the following advice, in this case replacing the usage of =compile= within function =foo=.

#+begin_src elisp
  (defun dtache-replace-compile-advice (orig-fun &rest args)
    "Replace `compile' with `dtache'.
  This is done before ORIG-FUN is passed ARGS."
    (cl-letf* (((symbol-function 'compile)
                (lambda (command &optional _)
                  (dtache-start-session command))))
      (apply orig-fun args)))

  (advice-add #'foo :around #'dtache-replace-compile-advice)
#+end_src

** Evil bindings

For inspiration on how to configure =dtache-list-sessions= to use evil bindings see [[https://gitlab.com/niklaseklund/dotfiles/blob/master/.config/emacs/init.el#L1393][Niklas Eklund's Emacs config]].

* Credits

I got inspired by =Ambrevar's= pursuits on [[https://ambrevar.xyz/emacs-eshell/][using eshell as his main shell]], and his [[https://github.com/Ambrevar/dotfiles/blob/master/.emacs.d/lisp/package-eshell-detach.el][package-eshell-detach]] got me into the idea of using =dtach= as a base for detachable shell commands.
